---
title: "Household Size"
author: "Jens von Bergmann"
date: "2017-08-10"
output: html_notebook
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The [`dotdensity` R package](https://github.com/mountainMath/dotdensity) provides dot-density functions can be used with any kind of data, but it has been designed with hierarchical
geographic data, like census data, in mind. 

## Household Size
For this example we are interested in the household size. 
We will make use of the [cancensus](https://github.com/mountainMath/cancensus) package to obtain census
data on the number of people per household in the City of Toronto.

```{r}
#devtools::install_github('mountainmath/dotdensity')
library(dotdensity)
#devtools::install_github('mountainmath/cancensus')
library(cancensus)
# options(cancensus.api_key)='<your API key>'
```



Using the [CensusMapper API tool](https://censusmapper.ca/api/CA16) we select the region and
variables we need.
```{r, message=FALSE, warning=FALSE}
dataset='CA16'
regions=list(CSD="3520005")
vectors=c("v_CA16_419","v_CA16_420","v_CA16_421","v_CA16_422","v_CA16_423")
census_data <- cancensus.load(dataset='CA16', regions=regions, vectors=vectors, level='CT')

```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=4, fig.width=4}
theme_opts<-list(ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),
                       panel.grid.major = ggplot2::element_blank(),
                       panel.background = ggplot2::element_rect(fill = 'light blue', colour = NA),
                       plot.background = ggplot2::element_rect(fill="light grey",
                       size=1,linetype="solid",color="black"),
                       axis.line = ggplot2::element_blank(),
                       axis.text.x = ggplot2::element_blank(),
                       axis.text.y = ggplot2::element_blank(),
                       axis.ticks = ggplot2::element_blank(),
                       axis.title.x = ggplot2::element_blank(),
                       axis.title.y = ggplot2::element_blank(),
                       plot.title = ggplot2::element_text(size=22)))

base_geom <- cancensus.load(geo_format='sp',dataset=dataset, regions=regions, level="Regions")

basemap <-   ggplot2::ggplot(base_geom) +
    ggplot2::geom_polygon(ggplot2::aes(long, lat, group = group), fill = "white", size=0.1) +
    #ggplot2::geom_polygon(ggplot2::aes(long, lat, group = group), colour = "#222222", fill = "white", size=0.1) +
    ggplot2::guides(colour = ggplot2::guide_legend(override.aes = list(size=2))) +
    ggplot2::labs(color = "label",caption="Source: StatCan Census 2016 via cancensus & CensusMapper.ca") +
    ggplot2::coord_map(projection="lambert", lat0=49, lat=49.4) +
    theme_opts
```


We have defined a convenience function `prep_data` that renames variables.
```{r, message=TRUE, warning=TRUE, include=FALSE}
# rename columns for better readability and compute aggregates
prep_data <- function(geo){
  data <- geo@data %>% replace(is.na(.), 0)
  labels <- attributes(geo)$census_labels
  vs=labels$Vector
  old_names=names(data)
  for (i in 1:length(vs)) {
    old_names[old_names==vs[i]] <- labels$Detail[labels$Vector==vs[i]]
  }
  names(data)=old_names

  geo@data <- data
  attributes(geo)$dot_labels <- labels
  return(geo)
}
```
Armed with that we load in the geographic data for the dissemination blocks and the census data for the dissemination areas. As a pre-caution the census tract level data in case we are missing dissemmination block level data due to privacy or quality concerns, which in this particular case wasn't the case.
```{r, message=FALSE, warning=FALSE}

data_ct <- cancensus.load(geo_format='sp',labels='short',dataset=dataset, regions=regions, vectors=vectors,level="CT") %>% prep_data
data_da <- cancensus.load(geo_format='sp',labels='short',dataset=dataset, regions=regions, vectors=vectors,level="DA") %>% prep_data
data_db <- cancensus.load(geo_format='sp',labels='short',dataset=dataset, regions=regions, vectors=vectors,level="DB") 
```
## Mapping

The categories we want to map consist of all the loaded census language variables. We pick colours to represent these, decide on a scale (how many dots per household) to map as well as the opacity and size of each dot.
```{r}
# Set the categorie we want to map. Those are the labels except we want to replace the "Total" with the "Other" column
categories=attributes(data_ct)$dot_labels$Detail
colors=c("#0000ff", "#ff0000", "#ffff00", "#00ff00", "#00ffff")
scale=50
alpha=0.75
size=1

```
```{r, echo=FALSE, message=FALSE, warning=FALSE}
# set map title using the scale and colour values
title=paste0("Number of Households by Household Size\n1 dot = ",scale," households")
basemap <- basemap + ggplot2::scale_colour_manual(title,values = colors) 
```


All that's left to do is re-aggregate and compute the dot locations and map them.
```{r, fig.width=12}
data_da@data <- dot_density.proportional_re_aggregate(data=data_da@data,parent_data=data_ct@data,geo_match=setNames("GeoUID","CT_UID"),categories=categories,base="Households")
data_db@data <- dot_density.proportional_re_aggregate(data=data_db@data,parent_data=data_da@data,geo_match=setNames("GeoUID","DA_UID"),categories=categories,base="Households")

dots.db <- dot_density.compute_dots(geo_data = data_db, categories = categories, scale=scale)
basemap + dot_density.dots_map(dots=dots.db,alpha=alpha,size=size)
```
##Takeaway
By changing a couple of lines of code in the [previous example about languages spoken at home in Vancouver](https://github.com/mountainMath/dotdensity/blob/master/vignettes/languages-example.Rmd) and taking out explanatory steps we could easily build a dot-density map of household size in Toronto. Using `cancensus`, pulling in the relevant data was a breeze, and the `dotdensity` package did all the relevant dot-density calculations for us.
